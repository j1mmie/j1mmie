# 2023
## Dec 28, 3:35pm

First .plan entry on Github. I've maintained a .plan file for a few months now but much of the information is private. I've decided to start a public .plan file to keep track of my progress, help stay motivated, and share the progress of my projects (currently, mainly, Slipstream) with the community.

Most of my .plan writing is stream of consciousness. However, when I am working on a particularly nebulous problem, it helps to write about it more coherently so that I can really wrap my head around it. Today is one of those days:

Today I am continuing work to reorganize our database's datascheme so that it is easier to perform bulk operations on. To do that, I needed to rip out our previous Object Document Mapping (ODM) layer (Typesaurus). Typesaurus hasn't provided much benefit and has in fact hidden some functionality of Firestore.

Firestore's default library is not much better however, so I had to write my own ORM, or ODM, or whatever, to make it easier to work with. Right now its called DocumentProxy, following the naming conventions of Firestore (DocumentReference, DocumentSnapshot, etc). It is not currently following the ActiveRecord design pattern, but I think it should eventually.

The feature that spurred this reorg / refactor is the ability to reward players with XP periodically, outside of battle. The challenges that I faced were:

1. The Firestore API does not support batch-updating across multiple subcollections.

    You can only do batch updates to subcollections on one parent collection.

2. The Firestore client SDK does not provide a way to store data changes in memory.

    You can make data changes to the DB, but then you can't modify the data mapping. So if you want to reserialize a record after you've changed it, you need to fetch it again from the DB. This is by design, and there are reasons for it, but Typesaurus did this and worked fine. So I'm creating a lighter-weight ODM layer similar to Typesaurus, but does not hide the underlying Firestore SDK data.

The reorg / refactor is working locally as far as I can tell. My biggest concerns are:

1. Data integrity

    The Firestore client SDK's set and update methods by default will delete any keys that exist in the DB but aren't included in the payload. In most cases today, I think this is not what I want. But I may have missed or misunderstood the behavior in some parts. So I have to test and make sure that data doesn't randomly go missing.

2. Faults

    The Firestore client SDK's default behavior when a transaction fails is to throw an error. In the Slipstream game and auth servers, these errors must be caught and recovered from. But I must make sure that I've caught all of these instances and that the recovery behavior is well defined.

Aside from the data access layer, I also have some concerns for the feature I'm working on (periodic XP rewards)

3. Recovery

    Ensure that if an XP grant fails, the game server retries granting that same XP so that the player gets their reward eventually.

4. No "double-spend"

    XP received in game should never be rewarded to a player more than once. However, I don't want this to come at the cost of not rewarding players for legitimate XP. So, if it comes to this vs "Recovery", I would favor Recovery.

5. No overlap of reward systems

    There is already a system in the game-servers to reward players with XP after a battle ends. This is not done in bulk, but rather as separate transactions done 1-by-1 asynchronously. I must ensure that XP awarded out of battle does not get counted toward the in-battle reward system. And this must also be true if a reward attempt has failed and is pending retry.

Next steps:

1. Continue testing data reorganization and integrity.
2. Ensure out-of-battle rewards still function as expected
3. Continue working on PendingProgressionRewards system
4. Refactor PostBattleProgressionRewardsProcessor to work with the new batching API, and ensure it can recover from failures

## Dec 29, 3:51pm

Noticed an issue where RPCClient was not properly cleaning up its notification subscriptions when disposed. This caused the client to request all static data N times, where N was the number of times the user re-authenticated per session. That's resolved. It didn't seem to have any side effects, but its resolved.

Back to testing the integrity post-reorg. My plan is to deploy this and migrate data tonight, comandeer Eric and Alfredo to help do regression testing, then continue work on out-of-battle XP once the dust has settled.

